\subsection{Aplicación web}
\label{subsec:tecAppWeb}

La nueva aplicación web de \textit{VSCode4Teaching} se basa en \textbf{Angular}, que emplea \textbf{Node} como plataforma subyacente, que se implementa utilizando el lenguaje \textbf{TypeScript} y que hace uso de bibliotecas para la comunicación con el servidor (\textbf{RxJS}), para la interacción con el sistema local de ficheros (mediante la \textbf{File System Access API}) y para la mejora de la \textbf{interfaz de usuario}.

\subsubsection{Angular}
\label{subsec:tecAngular}
Angular es un ``\textit{framework}\footnote{\textit{Framework}. Del inglés ``marco de trabajo'', es un conjunto de conceptos, prácticas y estándares que facilitan la consecución de un determinado objetivo, como la creación de aplicaciones o la gestión de un proceso \textit{software}.} web que facilita a los desarrolladores la creación de aplicaciones rápidas y fiables''\cite{Tec_Angular}. Fue desarrollado y está activamente mantenido por una subdivisión de Google, es de código abierto divulgado bajo licencia MIT y permite la generación de aplicaciones web SPA\footnote{SPA. Siglas de ``aplicación de página única'' (del inglés \textit{Single Page Application}).} orientadas a componentes.

Las aplicaciones web SPA son aquellas que requieren una única obtención de sus contenidos básicos (su estructura declarada mediante HTML, sus hojas de estilo en formato CSS y sus \textit{scripts} implementados mediante JavaScript) en la primera petición efectuada, actualizando su interfaz durante la interacción de los usuarios ejecutando peticiones en segundo plano y actualizando en consecuencia el DOM\footnote{DOM. Siglas de ``modelo de objetos del documento'' (del inglés \textit{Document Object Model}). Es uno de los objetos principales en el contexto de un navegador web y contiene una estructura arborescente mutable y navegable que representa los elementos dispuestos en la interfaz de una web y se genera a partir del código HTML recibido.}. Este tipo de aplicaciones aporta ventajas en materia de rendimiento, ya que en la primera petición se devuelve todo el código y los \textit{scripts} necesarios, soliendo ser más costosa en tiempo y memoria, mejorando así la experiencia de usuario en las sucesivas interacciones dentro de la propia aplicación \cite{SPA_Ventajas}.

Otra de las principales características que suele acompañar al desarrollo de aplicaciones web SPA es su orientación a componentes. Por ejemplo, Angular define el concepto de componente como ``el bloque fundamental para la creación de aplicaciones'' \cite{Angular_Componentes}. Este \textit{framework} fundamenta su arquitectura en la disposición de los componentes y las interrelaciones que establecen entre sí. Tal ha sido su popularización por parte de las bibliotecas de generación de aplicaciones SPA que este concepto está en vías de ser integrado en los estándares de HTML y JavaScript para su utilización sin necesidad de bibliotecas adicionales a través de los \textit{Web Components} \cite{WebComponents}, siendo compatibles aún solo con las versiones más modernas de los navegadores más populares.

Tras exponer las principales ventajas aportadas por las aplicaciones web SPA, cabe analizar el estado del arte a este respecto. Son tres las tecnologías más recurrentemente empleadas: React, Vue y Angular. La \textit{Encuesta de Desarrolladores} de Stack Overflow señala en su edición de 2023 que React es la tecnología para \textit{frontend} favorita para el $42,87\%$ de desarrolladores profesionales encuestados, frente a Angular ($19,89\%$) y Vue ($17,64\%$) \cite{subsec:tecAppAngularSurvey}.

Del citado artículo junto con otro que remarca las diferencias entre Angular y React \cite{AngularReact}, se extrapolan algunos puntos clave sobre las dos opciones más extendidas. Por un lado, Angular, aunque tiene una curva de aprendizaje más compleja, está bien mantenido y documentado, es escalable, favorece la modularidad y se basa en TypeScript; mientras que React mejora en rendimiento durante la renderización, es más fácil de aprender, únicamente se preocupa de la vista, requiriendo dependencias adicionales para dar soporte a las demás capas de la arquitectura; e introduce una sintaxis propia (JSX) para intercalar HTML y JavaScript.

Es necesario reseñar, además, una diferencia radical entre ellos: mientras que Angular es un \textit{framework} ``completo'' que impone ciertos conceptos y prácticas durante el ciclo de desarrollo y que toma el control de la aplicación en tiempo de ejecución, React es una ``biblioteca para interfaces de usuario web y nativas'' \cite{React} que requiere de la instalación de librerías adicionales para alcanzar una funcionalidad similar. Esta diferencia es fundamental, ya que permite a Angular brindar mecanismos como la inyección de dependencias, que facilita su aprendizaje a desarrolladores acostumbrados a la orientación a objetos, mientras que React utiliza objetos del ámbito global en el navegador para la compartición del estado entre componentes.

Al ser un \textit{framework}, Angular está ``opinionado'' (por traducción literal del inglés ``opinionated''); esto es, su uso viene marcadamente influenciado por las sugerencias que elaboran sus propios creadores para hacer las aplicaciones, pasando por la utilización de un determinado lenguaje ---TypeScript---, de una determinada arquitectura ---basada en componentes--- y de, en definitiva, un método recomendado pero no obligado para el desarrollo de proyectos.

El \textit{framework} utilizado en este proyecto es Angular. A todas las ventajas justificadas anteriores se suman, además, tres factores dependientes del contexto: es el \textit{framework} empleado en la asignatura de Desarrollo de Aplicaciones Web del Grado en Ingeniería del \textit{Software}, lo que facilita su posterior mantenimiento por otros autores en el contexto en el que se viene desarrollando este proyecto; ya se venía utilizando en \textit{VSCode4Teaching}, que ya contaba con una pequeña aplicación web basada en Angular como página de inicio y para la implementación del registro de nuevos profesores mediante invitación ---tal como se introduce en la \referenciaSeccion{sec:cronologiaProyecto}---; y su uso se basa en las mismas plataformas que la extensión para Visual Studio Code, que son TypeScript como lenguaje de programación y Node como plataforma subyacente, lo que hace que tenga una curva de aprendizaje compartida entre los dos componentes y, además, facilita la posibilidad de reutilización de código.

El ecosistema de Angular dispone de una amplia variedad de funcionalidades que se pueden emplear en estas aplicaciones, entre las que destacan: Angular CLI, una herramienta por línea de comandos que ayuda a los desarrolladores a generar \textit{scaffoldings}\footnote{\textit{Scaffolding}. Del inglés ``andamio'', alude al conjunto de ficheros que conforman una plantilla inicial sobre la que se asienta una nueva unidad \textit{software}.} de nuevas piezas \textit{software}, a actualizar la versión de las dependencias Angular añadidas o a ejecutar, compilar y desplegar las aplicaciones, entre otros; Angular Forms, que permite controlar integralmente el funcionamiento de los formularios, con métodos avanzados para la validación de las entradas y proporcionando \textit{two-way data binding} (es decir, la capacidad de cambiar el valor de variables a partir de la interfaz de usuario, y viceversa); o Angular Router, para hacer aplicaciones SPA con capacidad de establecer un sistema de enrutamiento virtual que permita diferenciar las distintas pantallas disponibles. Además de todas las citadas, que han sido utilizadas en la aplicación web, existen algunas más, como SSR, para habilitar \textit{Server-Side Rendering}, de modo que la vista se renderice en el servidor y el cliente la reciba preparada para inyectarla en el DOM; Material, que añade una amplia colección de componentes preparados para la interacción con los usuarios; o Localize, que facilita ofrecer una misma aplicación en múltiples idiomas.

Este proyecto utiliza Angular 16, publicado en mayo de 2023. Habitualmente, se libera una versión \textit{major}\footnote{\textit{Major}. En el sistema de versionado semántico\footnotemark, primera cifra en la nomenclatura de cada versión. Un salto de versión \textit{major} puede no ser retrocompatible.}\footnotetext{Versionado semántico. Sistema para la nomenclatura de nuevas versiones que se basa en la concatenación de tres secuencias numéricas: \textit{major}, \textit{minor} y \textit{patch}, ampliamente utilizado \cite{SemVer}.} nueva del \textit{framework} cada seis meses, hecho que dificulta mantener actualizados los proyectos a la última versión. Además, entre las versiones 16 y 17 se han producido numerosos cambios en el método de funcionamiento del \textit{framework}, por lo que se ha pospuesto la actualización a alguna versión más reciente.

\subsubsection{\textit{File System Access API}}
\label{subsec:tecFSA}
La \textit{File System Access API} (del inglés, ``interfaz para el acceso al sistema de ficheros'', y anteriormente llamada \textit{Native File System API}) es una interfaz proporcionada por algunos navegadores web para la interacción de las aplicaciones con el sistema de ficheros local de los usuarios.

Antes de entrar en detalle acerca de esta tecnología, cabe hacer un breve apunte acerca de la amplia variedad de navegadores web disponible y sus tendencias de uso. Según StatCounter \cite{UsoNavegadores}, los más utilizados en entornos de escritorio durante 2023 fueron Opera ($3,23\%$), Mozilla Firefox ($6,64\%$), Apple Safari ($8,8\%$), Microsoft Edge ($13,13\%$) y Google Chrome ($64,88\%$). Cada uno de estos navegadores ha sido creado y es mantenido por distintas corporaciones, hecho que ha conducido a una gran diversidad en los motores e intérpretes que utilizan. Los motores de renderizado son los componentes \textit{software} que los navegadores emplean para generar elementos gráficos a partir de la conjunción de la estructura definida mediante HTML y las hojas de estilo declaradas en CSS, siendo los más destacados \textit{WebKit} en el caso de Safari \cite{WebKit}, \textit{Gecko} en Firefox \cite{Gecko} y \textit{Blink} en los navegadores basados en Chromium \cite{Chromium}, Chrome y Edge \cite{Blink,EdgeChromium}. Por otro lado, los intérpretes de JavaScript, empleados para leer el código de los \textit{scripts} y ejecutarlo, son también diferentes para cada navegador, destacando \textit{SpiderMonkey} para Firefox \cite{SpiderMonkey} y \textit{V8} en el caso de Chrome y Edge \cite{V8}. Como resultado de esta heterogeneidad, se hace necesario revisar la compatibilidad de los \textit{scripts} implementados con las opciones disponibles en cada navegador, ya que un mismo código puede funcionar de forma diferente según el intérprete que lo ejecute.

La \textit{File System Access API} sienta sobre su base sobre la \textit{File System API} \cite{FileSystemAPI}, que es un ``estándar vivo'' de WHATWG (siglas de \textit{Web Hypertext Application Technology Working Group}), una comunidad integrada por desarrolladores encargados de actualizar muy frecuentemente varios estándares, entre los que destaca el que define HTML, promovida por grandes compañías de la informática como Apple, Mozilla Foundation u Opera. Este estándar define una interfaz para operar con sistemas de ficheros desde las aplicaciones web ejecutadas en el navegador a través de \textit{scripts}, estableciendo los métodos disponibles en los manejadores de ficheros (\textit{FileSystemFileHandle}) o directorios (\textit{FileSystemDirectoryHandle}) y en el BOM\footnote{BOM. Siglas de ``modelo de objetos del navegador'' (del inglés \textit{Browser Object Model}). Es el conjunto de objetos ofrecidos por el intérprete de un navegador, habitualmente designado como \texttt{window}, ya que suele ceñirse al contexto de una ventana o pestaña. Dentro de él se encuentra el DOM y permite ejecutar todas las operaciones accesibles del intérprete de \textit{JavaScript}, por lo que su funcionalidad depende del navegador empleado.}, tales como \textit{window.showOpenFilePicker}, para mostrar un diálogo que permita al usuario elegir un fichero en su sistema de ficheros local y dotar al navegador de un manejador del fichero basado en su contenido y metadatos; o \textit{window.showDirectoryFilePicker}, análogo para los directorios y sus contenidos; además de todos los métodos disponibles en las instancias concretas de las piezas \textit{software} que define este estándar.

Aunque esta API está parcialmente implementada en todos los navegadores, algunos de los más utilizados, como Firefox o Safari, restringen su uso a un sistema de ficheros privado y encapsulado localizado dentro del navegador llamado OPFS (siglas de ``sistema de ficheros de origen privado'', del inglés \textit{Origin Private File System}), accesible desde el BOM mediante el objeto \textit{navigator.storage}, de modo que estos navegadores no pueden operar con el sistema de ficheros local real del usuario que ejecuta una aplicación web que emplea esta API.

La \textit{File System Access API} propone complementar la \textit{File System API}. Esta API es actualmente un borrador divulgado por el WICG\footnote{WICG. Siglas de ``Grupo de la Comunidad para la Incubación de la Web'', del inglés \textit{Web Incubator Community Group}.}, que es un grupo dentro del W3C\footnote{W3C. Siglas de ``Consorcio Web'', del inglés \textit{World Wide Web Consortium}.} que sirve como ``lugar para la experimentación y discusión de nuevas características para la plataforma web'' \cite{WICG}. La propuesta de la \textit{File System Access API} tiene como propósito ``dotar a los desarrolladores de la capacidad para construir aplicaciones web que interactúen con ficheros en el dispositivo local del usuario [\dots], permitiendo modificar los archivos y trabajar con directorios'' \cite{FileSystemAccessAPI}. Para ello, propone la definición de los métodos \textit{queryPermission} y \textit{requestPermission}, que permiten solicitar permiso al usuario para ver o escribir (según se requiera) en el fichero o directorio que desee, dando como resultado una ampliación sobre las clases que ya proponía la \textit{File System API}. La definición de esta interfaz ampliada se preocupa de acotar los directorios que deben restringirse al implementarla en los navegadores, excluyendo los directorios críticos de los distintos sistemas operativos, aquellos que contienen el propio agente de usuario, la carpeta del usuario en sí misma y los directorios por defecto para el escritorio, los documentos o las descargas del usuario, entre otras.

Al no estar estandarizada, la compatibilidad de esta API queda restringida a cuantos navegadores la implementen. Los desarrolladores de Chrome son impulsores del uso de esta interfaz, lo que hizo que este navegador fuese el primero que dispusiese de ella, incorporándola en octubre de 2020. Además, publicaron un artículo divulgativo sobre ella en la que describen varios usos interesantes de la API acompañados de \textit{snippets}\footnote{\textit{Snippet}. Traducido literalmente del inglés como ``retal'', es un pequeño fragmento de código.} de código \cite{ArticuloChromeFsaAPI}: lectura y escritura de ficheros, especificación para guardar ficheros en local con sugerencia de nombre y ubicación, manejo de permisos concedidos por el usuario para acceder a un directorio, listado de contenidos de un directorio, creación o exploración de ficheros y directorios dentro de directorios, resolución de ruta relativa de ficheros localizados en directorios, renombrado, reubicación o eliminación de ficheros o directorios, integración con \textit{drag and drop}\footnote{\textit{Drag and drop}. Del inglés ``arrastrar y soltar'', se refiere a la capacidad para poder seleccionar uno o varios ficheros o directorios y arrastrarlos con el cursor hasta un área habilitada para la recepción, en la que se suelta el cursor. Es una interacción de usuario sustituta de la capacidad para elegir ficheros o directorios en un diálogo específicamente dispuesto con ese fin.} y métodos para el acceso al OPFS. Este artículo, además, va acompañado de una implementación de un editor web de ficheros localizados en el sistema local que, divulgado públicamente bajo licencia Apache 2.0, sirve como base y ejemplo de uso de gran parte de la funcionalidad de esta API \cite{ChromeLabsEditor}.

La heterogeneidad existente en la implementación de las interfaces por parte de los distintos intérpretes de los navegadores y la restricción vigente en Firefox y Safari, que no implementan los métodos de la \textit{File System Access API}, hace que el principal proceso de negocio de este proyecto, que es el intercambio bidireccional de ficheros entre el servidor y el cliente de \textit{VSCode4Teaching} para sincronizar las propuestas de los estudiantes y las plantillas de los ejercicios del profesorado, esté vigente únicamente en los navegadores Chrome, Edge y Opera, sumando un alcance de un $81,24\%$ de usuarios, aunque la restricción se puede ver fácilmente paliada al cambiar de navegador.

Una forma de mitigar parcialmente los efectos adversos derivados de esta divergencia en el funcionamiento de los navegadores es el uso de \textit{polyfills}, que son ``fragmentos de código que proveen la tecnología que se esperaría que un navegador proporcionase nativamente'' \cite{Polyfill}. En la práctica, los \textit{polyfills} funcionan en tiempo de ejecución, y detectan si el intérprete del navegador que los ejecuta dispone de los métodos deseados y, si no es así, añade una implementación efímera al vuelo, ya que quedará eliminada al cambiar de página.

Esta característica de sustitución en tiempo de ejecución que proponen los \textit{polyfills} puede no ser adecuada si se producen incompatibilidades entre la especificación original y la sustitutiva, pudiendo producir errores inesperados o difíciles de controlar. Para solucionar este problema, surge el concepto de \textit{ponyfill} \cite{Ponyfill}, que comparte finalidad con el anterior pero, en lugar de añadir implementaciones en tiempo real sobre las clases que no dispongan de los elementos deseados, propone una implementación independiente invocada utilizando una llamada a un módulo distinto, una biblioteca, que, internamente, dispondrá de una implementación no acoplada al estándar que se buscaba complementar originalmente, evitando utilizar la API nativa no soportada en su totalidad para garantizar que, con independencia de si el navegador que ejecuta el \textit{ponyfill} disponía de la funcionalidad deseada, funcione adecuadamente a través del mecanismo sustitutivo.

La contribución de los redactores del artículo de Chrome Labs anteriormente citado \cite{ArticuloChromeFsaAPI} no solo se ciñe al editor de texto, sino que, conscientes de la limitación para utilizar la API en algunos navegadores, implementaron y divulgaron un \textit{ponyfill} llamado \textit{browser-fs-access} \cite{BrowserFSAccess}, en el que también se basa el editor de texto que publicaron como caso de uso \cite{ChromeLabsEditor}, que dispone de implementaciones alternativas de los métodos de la \textit{File System Access API} basados en la utilización de elementos HTML como campos de tipo fichero o enlaces destinados a la descarga de documentos.

Este proyecto utilizó este \textit{ponyfill} para la implementación del proceso de sincronización de ficheros de estudiantes con el servidor, tal como se detalla en la \referenciaSeccion{subsec:rf11}. Además, se aprovecha la capacidad de este \textit{ponyfill} para advertir a los usuarios que utilizan navegadores no compatibles con la \textit{File System Access API} para mostrar por pantalla una recomendación para que cambien de navegador a otro que sí disponga de ella, tal como se define en la \referenciaSeccion{subsec:rn4}.

\subsubsection{RxJS}
\label{subsec:tecRxJS}
La programación reactiva es un paradigma de programación situado dentro del declarativo que basa su funcionamiento en el procesamiento de eventos asíncronos y en los flujos de datos \cite{ReactiveProgramming}. Esta marcada presencia de la asincronía se asocia intrínsecamente a una ejecución de código no bloqueante, declarando qué acciones se desearán ejecutar en el momento en que se reciba un dato a través de un flujo. Una vez declarado, continúa la ejecución del código sin pausarlo, ejecutando las acciones especificadas en el momento de recibir algún dato nuevo y dándolo a conocer a aquellos elementos que estén interesados en obtener la información procesada para, a su vez, producir nuevos eventos o alimentar otros flujos de datos.

La anterior descripción permite vislumbrar la aplicación práctica de un patrón de diseño clásico: \textit{Observer} \cite{GammaObserver}, en el que un informante tiene constancia de un grupo de observadores que quedan inscritos para recibir notificaciones sobre la modificación de su estado para, como consecuencia, realizar acciones derivadas de estas alteraciones. La programación reactiva bautiza al informante como ``observable'', a los observadores como ``suscriptores''; y a la acción que realizan estos sobre los primeros, ``suscripción''.

RxJS es una biblioteca para JavaScript y TypeScript que permite ``componer programas asíncronos y basados en eventos mediante la utilización de secuencias observables'' \cite{RxJS}. Divulgada como \textit{software} libre bajo licencia Apache 2.0, es una de las implementaciones del proyecto \textit{ReactiveX}, que propone múltiples implementaciones para llevar la programación reactiva a distintas plataformas \textit{software} \cite{ReactiveX}. Así, RxJS pone a disposición de sus usuarios clases que modelan observables y suscriptores a través de suscripciones, además de una amplia variedad de operadores para poder generar nuevos observables o para fusionar, transformar, mezclar o gestionar errores en los flujos asíncronos producidos por observables.

El cliente HTTP de Angular, incorporado por defecto en el \textit{framework}, permite preparar peticiones utilizando los observables de RxJS. Un uso típico estas tecnologías combinadas se ilustra en el \referenciaCodigo{cod:reqHttpAngular}, en el que se emplea un operador RxJS para convertir la información entrante en la respuesta de la petición en forma de DTO\footnote{DTO. Siglas de ``objeto de transferencia de datos'', del inglés \textit{Data Transfer Object}. Es un objeto sencillo que emplea tipos primitivos y que se utiliza para facilitar la transferencia de información entre componentes \textit{software}.} a una instancia del modelo y, además, un operador que permite cerrar automáticamente el observable al recibir la última respuesta (que, en una petición HTTP habitual, será la primera), finalizando el flujo asíncrono y desuscribiendo a sus observadores tras transmitir la respuesta procesada. Además, este último operador permite ``aplanar'' el flujo de datos: dado que se sabe que habrá una sola respuesta, es posible devolver una promesa\footnote{Promesa. En JavaScript y TypeScript, un objeto declarado asíncrono que devolverá eventualmente un valor afirmativo (resolución) o negativo (rechazo). Es estándar en JavaScript desde 2015, por lo que existen facilidades sintácticas del lenguaje para su uso \cite{Promise}.}, lo que, dado que están estandarizadas desde ES6 \footnote{ES6. Acrónimo de \textit{ECMAScript 6}, estándar del lenguaje JavaScript publicado en 2015. Los estándares publicados por ECMA son los más extendidos y empleados para generar intérpretes de JavaScript \cite{ES6}.}, facilita la codificación posterior.

\begin{lstlisting}[language=TypeScript,caption={Ejemplo de petición HTTP con el cliente de Angular (dependencia inyectada) y un observable de RxJS.},label=cod:reqHttpAngular]
public constructor(private http: HttpService) {}

public getCourseById = (id: number): Promise<Course> =>
    lastValueFrom(this.http.get<CourseDTO>("/course/" + id.toString())
        .pipe(map((courseDTO: CourseDTO) => new Course(courseDTO)))
    );
\end{lstlisting}

Sin embargo, resulta interesante emplear el comportamiento estándar de un observable de RxJS ---es decir, sin convertirlo en una promesa---, por ejemplo, al utilizar una conexión mediante \textit{Web Sockets}. Este protocolo permite dejar una conexión abierta bidireccional entre emisor y receptor, de modo que un observable sirve como interfaz para la recepción de mensajes de un \textit{web socket}, procesando las entradas e informando en el momento de la recepción a los suscriptores existentes, quienes pueden efectuar las acciones programadas como respuesta a la ocurrencia del citado evento asíncrono.

\subsubsection{TypeScript}
\label{subsec:tecTS}
Según Microsoft, creadores e impulsores de este proyecto, TypeScript es un ``lenguaje fuertemente tipado que transpila a JavaScript, brindando a los desarrolladores mejores herramientas a cualquier escala'' \cite{TypeScript}. Divulgado como código abierto bajo licencia Apache, TypeScript es un lenguaje de programación con tipado fuerte que proporciona una envoltura alrededor de JavaScript, aportando las principales ventajas del uso de tipos, como la detección de errores en tiempo de compilación como consecuencia de un mal uso de las variables según sus tipos definidos. Su uso se basa en un transpilador\footnote{Transpilador. Tipo particular de compilador que genera código fuente en un lenguaje a partir de código fuente en otro lenguaje.}, \textit{tsc}, que convierte el código TypeScript en su correspondiente JavaScript.

De las tecnologías analizadas en la \referenciaSeccion{subsec:tecAngular}, Angular es el único \textit{framework} de aplicaciones web para cliente que emplea TypeScript como lenguaje recomendado para su utilización durante el desarrollo. El propio \textit{framework} está implementado con este lenguaje e incorpora \textit{per sé} todas las herramientas necesarias para generar JavaScript automáticamente durante los procesos de construcción o ejecución de la aplicación con el fin de favorecer el uso de este lenguaje.

\subsubsection{Node}
\label{subsec:node}
Node.js (habitualmente denominado ``Node'') es un ``entorno de ejecución de JavaScript gratuito, de código abierto y multiplataforma que permite crear servidores, aplicaciones web, herramientas para línea de comandos y scripts'' \cite{Node} que se basa en V8, el intérprete de JavaScript que emplean navegadores como Chrome o Edge.

Si bien la intención original del lenguaje JavaScript, sexto lenguaje más usado con una cuota de uso del $3,32\%$ según TIOBE \cite{TIOBE} en junio de 2024, era la de dotar de dinamismo a las aplicaciones web mediante \textit{scripts} ejecutados en los navegadores al cargar las páginas, sus prestaciones han aumentado y en la actualidad dispone de herramientas de forma nativa que permiten trabajar mediante eventos asíncronos de forma sencilla, facilitando la creación de aplicaciones fundamentadas en el intercambio de información por red. La finalidad de Node es la traslación de estas ventajas a la posibilidad de ejecutar aplicaciones basadas en este lenguaje directamente como procesos en el sistema operativo para generar aplicaciones de escritorio o herramientas por línea de comandos.

Este último es el caso de Angular. Como se introduce en la \referenciaSeccion{subsec:tecAngular}, este \textit{framework} dota al desarrollador de una herramienta por línea de comandos que permite, entre otros procesos, ejecutar la aplicación o compilarla, para lo que se basa en herramientas asentadas en la plataforma Node. Además, por ejemplo, la capacidad para incorporar \textit{server-side rendering} (SSR) hace uso de un pequeño proceso Node a instalar en el servidor que se encarga de la generación de las vistas renderizadas transmitidas al cliente.

Otra de las capacidades asociadas a los proyectos basados en la plataforma Node es la utilización de un gestor de dependencias instalado por defecto junto con la distribución habitual de Node, que es NPM (siglas de \textit{Node Package Manager}). Además de un gestor de dependencias, NPM dispone de un repositorio público impulsado por GitHub con una gran cantidad de módulos reutilizables para los proyectos Node \cite{npmjscom}. Este gestor de dependencias se basa en las declaraciones albergadas en el fichero \texttt{package.json} que existe en la raíz de los proyectos Node, instalando todas las dependencias declaradas y sus transitivas en el directorio \texttt{node\_modules}. En el \referenciaCodigo{cod:packageJsonAngular} se introduce un fragmento del fichero \texttt{package.json} de la aplicación web para Angular, en el que se observa la declaración de algunos atributos básicos, tales como el nombre o la versión, de algunos atajos para la ejecución de \textit{scripts} que permiten ejecutar la aplicación o construirla y la declaración de dependencias, tanto las requeridas en tiempo de ejecución (\texttt{dependencies}) como las únicamente requeridas para el desarrollo (\texttt{devDependencies}).

\begin{lstlisting}[language=JavaScript,caption={Fragmento del documento \texttt{package.json} de la aplicación web Angular.},label=cod:packageJsonAngular]
{
    "name": "vscode4teaching",
    "version": "3.0.0",
    "scripts": {
        "start": "ng serve",
        "build": "ng build",
        // ...
    },
    "dependencies": {
        "@angular/common": "^16.2.9",
        "@angular/core": "^16.2.9",
        "@angular/forms": "^16.2.9",
        "@angular/router": "^16.2.9",
        // ...
    },
    "devDependencies": {
        "@angular/cli": "~16.2.6",
        "typescript": "^5.1",
        // ...
    }
}
\end{lstlisting}

\subsubsection{Interfaz de usuario: SCSS, Bootstrap y Chart.js}
\label{subsec:tecGUI}
A todas las tecnologías desarrolladas durante las subsecciones anteriores, se añaden algunas otras bibliotecas y tecnologías empleadas para facilitar la generación de una interfaz de usuario visualmente atractiva, fácilmente operable e intuitiva. Para ello, se han empleado \textbf{SCSS} como preprocesador de hojas de estilo, \textbf{Bootstrap} como biblioteca para la disposición básica de los elementos y \textbf{Chart.js} como ejemplo de biblioteca para la generación de componentes visuales avanzados.

CSS (siglas en inglés de ``hojas de estilo en cascada'') es el lenguaje declarativo empleado de forma estándar para la definición de los estilos que se deben aplicar sobre la definición de la estructura de una visualización web a través de una maqueta en HTML. Este estándar es mantenido por un grupo de trabajo del W3C \cite{CSS_W3C}, y es aplicado por todos los motores de renderizado de los navegadores más empleados.

De una forma similar a como TypeScript envuelve JavaScript, alrededor de CSS surgió \textbf{Sass} (``hojas de estilo sintácticamente increíbles'', del inglés \textit{Syntactically Awesome Style Sheets}) \cite{Sass}, que introduce algunas características de las que CSS no disponía en sus versiones más antiguas, como el uso de variables, el anidamiento de selctores y reglas u operadores automáticos. Sass es de código libre, está divulgado bajo licencia MIT, y que ofrece dos sintaxis: SCSS, que emplea el mismo concepto sintáctico que CSS; o la sintaxis indentada, que elimina los caracteres de separación de ámbitos y reglas y los sustituye, respectivamente, por tabulaciones y saltos de línea. Proporciona un transpilador que permite generar el CSS compatible con los motores de renderizado.  

Angular ofrece soporte a la transpilación de Sass, incorporándola al proceso de ejecución y construcción de aplicaciones de forma automática, pudiendo configurar en los proyectos si harán uso de CSS o de alguna de las dos sintaxis que propone Sass. La aplicación web de \textit{VSCode4Teaching} define sus hojas de estilo haciendo uso de la sintaxis SCSS.

\textbf{Bootstrap} es un ``conjunto de herramientas para \textit{frontend} poderoso, extensible y empaquetado por características'' que ``está construido con Sass, utiliza un sistema de cuadrícula y aporta componentes a través de poderosas extensiones JavaScript'' \cite{Bootstrap} publicado como \textit{software} libre bajo licencia MIT. Ofrece una especificación de estilos básica para todos los elementos visuales, aportándoles una estética común, además de un conjunto de componentes funcionales JavaScript básicos, entre los que destacan las ventanas modales embebidas.

\textbf{Chart.js} es una biblioteca ``simple y flexible'' \cite{ChartJS} para generar gráficos de diversa índole a partir de una configuración básica y una serie de datos. Específicamente, se utiliza para generar un gráfico semicircular representativo del progreso de los estudiantes al realizar un ejercicio (véase la \referenciaSeccion{subsec:rf3}).
