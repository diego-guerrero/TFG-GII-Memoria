\section{Metodología: proceso \textit{software}}
\label{sec:metodologia}

La historia de la ingeniería del \textit{software}, aunque corta en el tiempo ---ya que surgió hace poco más de medio siglo---, es muy prolífica, y ha dado lugar a una gran lista de técnicas, herramientas y métodos organizativos empleados por los equipos para la correcta organización de los proyectos \textit{software}, favoreciendo la adecuada fragmentación de las tareas, su jerarquización y su planificación temporal para alcanzar un funcionamiento óptimo.

En el año 1986, Barry Boehm publicó un artículo en el que sentó las bases del \textbf{modelo en espiral} \cite{ModeloEspiral}, que, de forma resumida, propone que el proceso \textit{software} debe ser iterativo e incremental. Iterativo porque deben ejecutarse las mismas fases tantas veces como sea necesario (y no solo una, como proponía el método en cascada), e incremental porque cada iteración produce un nuevo aumento del \textit{software} construido.

Aunque sienta sus bases en trabajos anteriores, en 1995, Grady Booch propuso el enfoque realizado en Rational (perteneciente posteriormente a IBM) de un proceso \textit{software} basado en componentes, dirigido por casos de uso, centrado en la arquitectura y con un carácter iterativo e incremental. El posteriormente denominado \textbf{proceso unificado de desarrollo} tras la publicación realizada en 1999 por Booch, Jacobson y Rumbaugh \cite{RUP}, conocido por sus siglas RUP (del inglés \textit{Rational Unified Process}), es un proceso que pone en el centro de su ejecución los casos de uso, que sirven como enlace entre los requisitos y el diseño e implementación; y la arquitectura, que es primordial para la posterior construcción y evolución del sistema desarrollado. Hace un uso intensivo del lenguaje unificado de modelado (UML, por sus siglas en inglés \textit{Unified Model Language}) que, surgido en la misma corporación y divulgado por los mismos autores, establece una sintaxis gráfica para la expresión del funcionamiento y organización del \textit{software} ampliamente consolidada en esta ingeniería \cite{UML}.

También en 1999, Kent Beck publicó un libro acerca de un nuevo proceso \textit{software}: \textbf{eXtreme Programming} (XP) \cite{XP}. Propone una modificación del enfoque, haciendo mayor énfasis en la adaptabilidad frente al cambio que en la previsibilidad, considerando que los cambios sobre los requisitos son parte intrínseca de la naturaleza de los proyectos. En consonancia con este principio, XP propone nuevas técnicas para la ingeniería del \textit{software}, como la programación por pares (\textit{pair programming}), las buenas prácticas para la refactorización del código, el desarrollo guiado por las pruebas (TDD) o las historias de usuario, cuyo propósito es centrar cada requisito en el valor que aportará al usuario final.

Si bien los tres procesos desarrollados anteriormente sientan las bases de la ingeniería del \textit{software} tal como es en la actualidad, en la que la iteratividad e incrementalidad son los dos principios básicos que rigen todos los procesos \textit{software}, estos fueron opacados por la publicación del \textit{Manifiesto Ágil} en 2001 \cite{AgileManifesto}, que afirma que los procesos \textit{software} deben sentar sus bases en cuatro pilares: la preponderancia de individuos e interacciones sobre procesos y herramientas, el \textit{software} funcional sobre la documentación extensiva, la colaboración con el cliente sobre la negociación contractual y la respuesta frente al cambio sobre la planificación exhaustiva. Dentro de estos principios encajan múltiples procesos de anterior publicación, como Scrum (1995), Kanban (década de 1940) o XP, cuyas buenas prácticas gozan de una gran popularidad en la actualidad.

En general, y en esta ingeniería en particular, la historia es una gran fuente de aprendizaje. La ingeniería del \textit{software} ha aportado durante su aún breve historia una ingente cantidad de técnicas para facilitar la ejecución del proceso \textit{software} en todas sus etapas: la ingeniería de requisitos, el diseño y análisis, la implementación, la validación del \textit{software} y la entrega y el despliegue.

La mayoría de los procesos \textit{software} están ideados para su utilización en equipos de desarrollo, por lo que su aplicación directa en proyectos con características tan específicas como los Trabajos Fin de Grado resulta ineficaz. Sin embargo, son muchas las buenas prácticas que se pueden tomar del histórico de conjuntos de técnicas y herramientas como ayuda y soporte para generar un nuevo proceso \textit{ad hoc} para el contexto concreto del presente Trabajo.

Tal como propone el modelo en espiral desde hace cuarenta años, el proceso \textit{software} de este Trabajo Fin de Grado se ha realizado de forma iterativa e incremental, buscando la completitud de cada uno de los requisitos antes de seguir avanzando: en lugar de extraerlos para diseñarlos e implementarlos todos, se han extraído, diseñado e implementado cada uno por separado, dando lugar a la ejecución reitrada de pequeñas iteraciones completas conducentes hacia pequeños incrementos hasta alcanzar la evolución deseada.

Por tanto, aunque durante la ejecución de este nuevo hito evolutivo de \textit{VSCode4Teaching} no se ha seguido a rajatabla ningún proceso \textit{software} consolidado, son numerosas las prácticas empleadas que se han extraído de los procesos más extendidos. Así, el proceso es iterativo e incremental, tal como propone el modelo en espiral, alcanzando un total de trece iteraciones; cuida la arquitectura y la sitúa en el centro, como propone RUP, haciendo uso de UML como lenguaje de modelado; y emplea el formato de historias de usuario para la especificación de los requisitos funcionales, inspirándose en XP.

Tal como queda reflejado en la \referenciaSeccion{sec:herTrello}, que trata acerca de la herramienta para la planificación, durante este Trabajo se hace uso de un tablero inspirado en Kanban para la organización visual de las tareas, separándolas en tres columnas según su estado temporal: pendientes de hacer, en proceso y finalizadas. También inspirado en Kanban, se establece un límite al trabajo en progreso (WIP, del inglés \textit{Work In Progress}), de modo que no se realiza más de un requisito en paralelo. El tablero empleado toma de Scrum la idea de añadir una columna adicional para albergar una pila de puntos restantes para completar los requisitos conocidos del producto, el \textit{product backlog}, del que se van extrayendo tarjetas que, en este caso, representan historias de usuario (XP) que quedan fraccionadas e introducidas en otra pila específica para la actual iteración, coincidente en este caso con la columna de tareas pendientes de iniciar.
